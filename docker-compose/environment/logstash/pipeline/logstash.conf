input {
  beats {
    port => 5044
  }
}

filter {
  grok {
    match => {
      "message" => [
        "^\[%{WORD:log_level}\] %{TIMESTAMP_ISO8601:timestamp} \| %{DATA:request_id} \| %{GREEDYDATA:content}$",
        "^\[%{WORD:log_level}\] %{TIMESTAMP_ISO8601:timestamp} \| %{GREEDYDATA:content}$"
      ]
    }
    tag_on_failure => ["_grokparsefailure"]
    add_field => { "grok_matched" => "true" }
  }

  if [grok_matched] == "true" {
    if [log_level] == "GIN" {
      grok {
        match => { "content" => "%{DATA:request_id} \| %{NUMBER:status_code:int} \| %{DATA:duration} \| %{IP:client_ip} \| %{WORD:http_method} %{GREEDYDATA:request_path}" }
        tag_on_failure => ["_gin_parse_failure"]
      }
    } else if [log_level] == "INFO" {
      grok {
        match => { "content" => "record consume log: %{GREEDYDATA:info_message}" }
        tag_on_failure => ["_info_parse_failure"]
      }
    }
  }

  date {
    match => [ "timestamp", "yyyy/MM/dd - HH:mm:ss" ]
    target => "@timestamp"
  }

  mutate {
    remove_field => [ "ecs", "agent", "input" ]
  }
}

output {
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    user => "elastic"
    password => "YourElasticPassword"
    index => "filebeat-%{+YYYY.MM.dd}"
  }
  stdout { codec => rubydebug }
}
